<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'phy' Dialect

This dialect defines a flattened graph of elements including free-running
processing elements (PEs), the memory that stores or registers data
(buffers), message-passing like streams or packets (networks), and memory
access with addresses (buses) that transmits data, with spatial
information, which is the connections and numbers of elements.
The elements defined in this dialect can be mapped to a physical location
or a set of wires of the devices.

[TOC]

## Operation definition

### `phy.addressedBus` (::phy::AddressedBusOp)

addressed bus creation operation


Syntax:

```
operation ::= `phy.addressedBus` `(` `)` attr-dict `:` type($bus)
```

The `phy.addressedBus` operation represents a creation of an addressed bus
that can have buffers mapped to its memory space using the 'phy.mmap'
operation.

Example:

```mlir
%buf = phy.buf() : memref<1024xi32>
%abus = phy.addressedBus() : !phy.addressedBus<i32>
phy.mmap(%abus[10:15], %buf[20:] : memref<1024xi32>)
%pe = phy.pe @func(%abus) : (!phy.addressedBus<i32>) -> !phy.pe
```

#### Results:

| Result | Description |
| :----: | ----------- |
| `bus` | a bus of any type

### `phy.addressedCache` (::phy::AddressedCacheOp)

creation of a cache layer between two addressed buses


Syntax:

```
operation ::= `phy.addressedCache` `(` $upstream `,` $downstream `)` attr-dict `:` type($cache)
```

An operation creating a cache to connect two buses.  With the cache,
the memory access on the 'downstream' bus from the buffers on the 'upstream'
bus will be cached, and the 'downstream' bus is able to receive data from
the buffers on the 'upstream' bus.  The 'phy.cache' type specifies the
number of elements that can be cached.

Example:

```mlir
%abus1 = phy.addressedBus() : !phy.addressedBus<i32>
%abus2 = phy.addressedBus() : !phy.addressedBus<i32>
%cache  = phy.addressedCache(%abus1, %abus2) : !phy.cache<i32, 1024>
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `upstream` | a bus of any type
| `downstream` | a bus of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `cache` | a cache of any type

### `phy.buf` (::phy::BufferOp)

buffer creation operation


Syntax:

```
operation ::= `phy.buf` `(` `)` attr-dict `:` type($buffer)
```

The `phy.buf` operation represents a creation of a buffer that has the type
argument as its datatype.  A buffer is a memory space that stores data.
A buffer can be randomly accessed through a bus, or sequentially through a
network.  It can have a device-specific attribute of location.

Example:

```mlir
%buffer = phy.buf() : memref<1024xi32>
```

#### Results:

| Result | Description |
| :----: | ----------- |
| `buffer` | statically shaped memref of any type values

### `phy.bus` (::phy::BusOp)

bus creation operation


Syntax:

```
operation ::= `phy.bus` `(` $endpoints `)` attr-dict `:` functional-type($endpoints, $bus)
```

The `phy.bus` operation represents a creation of a bus that has the type
argument as its datatype for data transfer.  When a PE wants to access a
buffer, there must exist a bus connecting the PE and the buffer.

Example:

```mlir
%buffer = phy.buf() : memref<1024xi32>
%pe     = phy.pe @func(%buffer) : (memref<1024xi32>) -> !phy.pe
%bus    = phy.bus(%buffer, %pe) : (memref<1024xi32>, !phy.pe) -> !phy.bus<i32>
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `endpoints` | a memref or a pe

#### Results:

| Result | Description |
| :----: | ----------- |
| `bus` | a bus of any type

### `phy.cache` (::phy::CacheOp)

creation of a cache layer between two buses


Syntax:

```
operation ::= `phy.cache` `(` $upstream `,` $downstream `)` attr-dict `:` type($cache)
```

An operation creating a cache to connect two buses.  With the cache,
the memory access on the 'downstream' bus from the buffers on the 'upstream'
bus will be cached, and the 'downstream' bus is able to receive data from
the buffers on the 'upstream' bus.  The 'phy.cache' type specifies the
number of elements that can be cached.

Example:

```mlir
%bus1   = phy.bus(%buffer) : (memref<1024xi32>) -> !phy.bus<i32>
%bus2   = phy.bus(%pe) : (!phy.pe) -> !phy.bus<i32>
%cache  = phy.cache(%bus1, %bus2) : !phy.cache<i32, 1024>
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `upstream` | a bus of any type
| `downstream` | a bus of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `cache` | a cache of any type

### `phy.device` (::phy::DeviceOp)

usage of a device


Syntax:

```
operation ::= `phy.device` `<` $device `>` regions attr-dict
```

An operation that uses an abstract physical device for the enclosing region.
The region is used to place and route elements onto the device.  The
locations for placement, and the wires for routing, are dependent on which
device is used.  This operation must be enclosed by a 'phy.platform' operation.

Example:

```mlir
phy.platform<"xilinx"> {
  phy.device<"hls"> {
    phy.place<"slr0">(%pe)
  }
}
```

Traits: HasParent<PlatformOp>, NoRegionArguments, SingleBlockImplicitTerminator<phy::EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `device` | ::mlir::StringAttr | string attribute

### `phy.end` (::phy::EndOp)

end of usage of platform or device


Syntax:

```
operation ::= `phy.end` attr-dict
```

'phy.end' is an implied terminator for the 'phy.platform' or 'phy.device'
regions.  You do not need to manually write it.

Traits: HasParent<PlatformOp, DeviceOp>, Terminator

### `phy.mmap` (::phy::MmapOp)

creation of a buffer into addressed bus memory space


Syntax:

```
operation ::= `phy.mmap` `(` $bus `[` $begin `:` $end `]` `,` $buffer `[` $offset `:` `]`
              `:` type($buffer) `)` attr-dict
```

An operation that maps the 'buffer' starting the 'offset'-th element,
into the 'bus'.  The mapped address is from 'begin'-th element
(inclusive), to the 'end'-th element (exclusive) on the bus.

Example:

```mlir
phy.mmap(%abus[10:15], %buf[20:] : memref<1024xi32>)
// abus[10] will be buf[20], abus[11] will be buf[21], ...
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `begin` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `end` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `offset` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `bus` | a bus of any type
| `buffer` | statically shaped memref of any type values

### `phy.net` (::phy::NetworkOp)

network creation operation


Syntax:

```
operation ::= `phy.net` `(` `)` attr-dict `:` type($network)
```

The `phy.net` operation represents a creation of a network that has the type
argument as its datatype for data transfer.  The network can be passed to PE
functions to connect them together for message-passing based communication.

Example:

```mlir
%net = phy.net() : !phy.net<i32>
```

#### Results:

| Result | Description |
| :----: | ----------- |
| `network` | a network of any type

### `phy.pe` (::phy::PeOp)

processing element creation operation


Syntax:

```
operation ::= `phy.pe` $callee `(` $operands `)` attr-dict `:` functional-type($operands, $pe)
```

The `phy.pe` operation represents a creation of a processing element that
has the function argument as its entry point.  The processing element will
be free-running and the function will be invoked.  The function must be
within the same symbol scope as the operation.  The operands must match the
specified function type. The function is encoded as a symbol reference
attribute named `callee`.

Example:

```mlir
%pe = phy.pe @my_adder(%net, %buf) : (!phy.net<i32>, memref<1024xi32>) -> !phy.pe
```

Interfaces: CallOpInterface, InferTypeOpInterface, SymbolUserOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | a memref, a network or an addressed bus

#### Results:

| Result | Description |
| :----: | ----------- |
| `pe` | A type specifiying a processing element

### `phy.place` (::phy::PlaceOp)

placement of an element


Syntax:

```
operation ::= `phy.place` `<` $location `>` `(` $element `:` type($element)  `)` attr-dict
```

An operation that place the 'element' to the specific location of the
enclosing device.  This operation must be enclosed by a 'phy.device'
operation.  The 'location' argument is device-dependent.  Please check
the documentation of the platform and device plugins.

Example:

```mlir
phy.platform<"xilinx"> {
  phy.device<"hls"> {
    phy.place<"slr0">(%pe)
  }
}
```

Traits: HasParent<DeviceOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `location` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `element` | a memref, a network, a router or a cache

### `phy.platform` (::phy::PlatformOp)

usage of a platform


Syntax:

```
operation ::= `phy.platform` `<` $platform `>` regions attr-dict
```

An operation that uses an abstract physical platform for the enclosing region.
The region is used to place and route elements onto the platform.  The
locations for placement, and the wires for routing, are dependent on which
platform is used.

Example:

```mlir
phy.platform<"xilinx"> {
  phy.device<"hls"> {}
  phy.route<"pl-aie">(%net1)
}
```

Traits: NoRegionArguments, SingleBlockImplicitTerminator<phy::EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `platform` | ::mlir::StringAttr | string attribute

### `phy.pop` (::phy::PopOp)

blocking network data receive


Syntax:

```
operation ::= `phy.pop` `<` $channel `>` `(` $network `)` attr-dict `:` type($result)
```

The `phy.pop` operation receive data from its operand network on the given
channel.  This operation is blocking and returns the received data as its
result.

Example:

```mlir
%0 = phy.pop<1>(%net) : i32
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `network` | a network of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `phy.push` (::phy::PushOp)

blocking network data send


Syntax:

```
operation ::= `phy.push` `<` $channel `>` `(` $data `:` type($data) `,` $network `)` attr-dict
```

The `phy.pop` operation send data to its operand network on the given
channel.  This operation is blocking and will continue when the data is
on the network.  It may return before the data is received from the network.
If multiple receivers are on the channel, they will each get a copy.

Example:

```mlir
phy.push<1>(%0 : i32, %net)
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `data` | any type
| `network` | a network of any type

### `phy.ready` (::phy::ReadyOp)

non-blocking network send test operation


Syntax:

```
operation ::= `phy.ready` `<` $channel `>` `(` $network `:` type($network) `)` attr-dict
```

The `phy.ready` operation tests its operand network if the given channel
is ready for sending data.  This operation is non-blocking and returns a
boolean result, which is true if it is ready to send, or false if it is not.

Example:

```mlir
%0 = phy.ready<1>(%net : !phy.net<i32>)
```

Interfaces: InferTypeOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `network` | a network of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 1-bit signless integer

### `phy.route` (::phy::RouteOp)

route of a communication path


Syntax:

```
operation ::= `phy.route` `<` $wires `>` `(` $communication `:` type($communication)  `)` attr-dict
```

An operation that route the 'communication' to the specific wires of the
enclosing device, platform, or global connections.  The 'wires' argument
is device-dependent, platform-dependent, or global-dependent.  Please check
the documentation of the platform and device plugins, or the global plugin.

Example:

```mlir
phy.platform<"xilinx"> {
  phy.device<"hls"> {
    phy.place<"slr0">(%pe)
  }
}
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `wires` | ::mlir::ArrayAttr | string array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `communication` | a network, a bus, or an addressed bus

### `phy.router` (::phy::RouterOp)

creation of a router connecting two networks


Syntax:

```
operation ::= `phy.router` `(` $network1 `,` $network2 `)` attr-dict `:` type($router)
```

An operation creating a router to connect two networks.  With the
connection, the data sent on either network will be received on the other.
The 'phy.router' type specifies the fifo size of the router.

Example:

```mlir
%net1   = phy.net() : !phy.net<i32>
%net2   = phy.net() : !phy.net<i32>
%router = phy.router(%net1, %net2) : !phy.router<i32, 2>
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `network1` | a network of any type
| `network2` | a network of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `router` | a router of any type

### `phy.startLoad` (::phy::StartLoadOp)

non-blocking load of the data


Syntax:

```
operation ::= `phy.startLoad` $memref `[` $indices `]` attr-dict `:` type($memref)
```

A non-blocking bus access that reads the data from a buffer, or an addressed
bus, as specified in 'memref'.  This operation returns a handle, which may be
waited using `phy.wait` to get the access result.

Example:

```mlir
%load_handle = phy.startLoad %mem[%idx] : memref<1024xi32>
%0 = phy.wait(%load_handle) : i32
```

Traits: MemRefsNormalizable

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `memref` | a memref or an addressed bus
| `indices` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `phy.startStore` (::phy::StartStoreOp)

non-blocking store of the data


Syntax:

```
operation ::= `phy.startStore` $value `,` $memref `[` $indices `]` attr-dict `:` type($memref)
```

A non-blocking bus access that stores the data to a buffer, or an addressed
bus, as specified in 'memref'.  This operation returns a handle, which may
be waited using `phy.wait`.

Example:

```mlir
%store_handle = phy.startStore %0, %mem[%idx] : memref<1024xi32>
phy.wait(%store_handle) : none
```

Traits: MemRefsNormalizable

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type
| `memref` | a memref or an addressed bus
| `indices` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `handle` | a handle of none type

### `phy.valid` (::phy::ValidOp)

non-blocking network receive test operation


Syntax:

```
operation ::= `phy.valid` `<` $channel `>` `(` $network `:` type($network) `)` attr-dict
```

The `phy.valid` operation tests its operand network if the given channel
has data to received.  This operation is non-blocking and returns a boolean
result, which is true if there is data to receive, or false if there is not.

Example:

```mlir
%0 = phy.valid<1>(%net : !phy.net<i32>)
```

Interfaces: InferTypeOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `network` | a network of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 1-bit signless integer

### `phy.wait` (::phy::WaitOp)

blocking wait until a handle is ready


Syntax:

```
operation ::= `phy.wait` `(` $handle `)` attr-dict `:` type($result)
```

A non-blocking bus access returns a handle, which may be waited using this
operation to get the access result.  For store access, none is returned.

Example:

```mlir
%0 = phy.wait(%load_handle) : i32
phy.wait(%store_handle) : none
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `handle` | a handle of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

## Type definition

### AddressedBusType

A type specifiying a bus with address mapping specification

Syntax:

```
!phy.addressedBus<
  Type   # datatype
>
```

A bus with its address space used by buffers.  In the defining operation, a
buffer can specify how its memory address space is mapped to the bus.  An
addressed bus can be used in the same way as a 'memref' in a PE with the
'phy.startLoad' and 'phy.startStore' operations.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| datatype | `Type` |  |

### BusType

A type specifiying a bus connecting PEs to buffers

Syntax:

```
!phy.bus<
  Type   # datatype
>
```

A bus connects PEs to buffers.  A buffer has its memory address space mapped
to the bus for PEs' access.  It can have a device-specific attribute of the
route.  A bus can be connected to an upstream bus using caches that provides
caching.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| datatype | `Type` |  |

### CacheType

A type specifiying a cache connecting two buses

Syntax:

```
!phy.cache<
  Type,   # datatype
  int   # size
>
```

A bus can be connected to an upstream bus using caches that provides caching.
The parameter 'size' specifies the elements to be stored in the cache.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| datatype | `Type` |  |
| size | `int` |  |

### HandleType

A type specifiying a on-going bus access

Syntax:

```
!phy.handle<
  Type   # datatype
>
```

A non-blocking bus access returns a handle, which may be waited to get the
access result.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| datatype | `Type` |  |

### NetworkType

A type specifiying a network to be connected by PEs

Syntax:

```
!phy.net<
  Type   # datatype
>
```

A network connects multiple PEs and/or buffers for message-passing.
It behaves as a first-in-first-out interconnect.  It can have a
device-specific attribute of its route.  A network can be connected with
another network using routers that provides in-transit buffers.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| datatype | `Type` |  |

### PeType

A type specifiying a processing element

Syntax: `!phy.pe`

A PE is a logical function that connects to networks or buses.  It can
communicate with another PE or buffer via networks, or buffer via buses.
It can have a device-specific attribute of location, e.g. a core in CPU,
a tile or a DMA region in AIE, or a reconfiguration slot in FPGA.

### RouterType

A type specifiying a router connecting two networks

Syntax:

```
!phy.router<
  Type,   # datatype
  int   # depth
>
```

A network can be connected with another network using routers that provides
in-transit buffers.  The parameter 'depth' specifies the depth of the fifo
buffer in the router.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| datatype | `Type` |  |
| depth | `int` |  |

